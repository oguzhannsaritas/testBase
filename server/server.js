import express from 'express';
import fs from 'fs';
import { exec } from 'child_process';
import cors from 'cors';
import path from 'path';
import axios from 'axios';

const app = express();
app.use(express.json());
app.use(cors());

const PORT = process.env.PORT || 5003;
const TESTS_DIR = path.join(process.cwd(), 'tests');
const VIDEOS_DIR = path.join(process.cwd(), 'videos');
const SCREENSHOTS_DIR = path.resolve(process.cwd(), 'screenshots');


const JENKINS_URL = 'http://localhost:8080/job/testBase/build';
const JENKINS_USER = 'oguzhansaritas';
const JENKINS_TOKEN = '11ebe8b143b2208b33e74508265c356812';
const JENKINS_LAST_BUILD_URL = 'http://localhost:8080/job/testBase/lastBuild/api/json';

// ‚úÖ **Jenkins'in en son build ID'sini alƒ±r**
async function getLastBuildId() {
    console.log("‚è≥ Build ID alƒ±nmadan √∂nce 5 saniye bekleniyor...");
    await new Promise(resolve => setTimeout(resolve, 5000));

    try {
        const response = await axios.get(JENKINS_LAST_BUILD_URL, {
            auth: { username: JENKINS_USER, password: JENKINS_TOKEN }
        });
        return response.data.id;
    } catch (error) {
        console.error("‚ùå Jenkins build ID alƒ±nƒ±rken hata:", error.message);
        return null;
    }
}

// ‚úÖ **Jenkins job'unun bitmesini bekler**
async function waitForJenkinsSuccess(buildId) {
    if (!buildId) {
        console.error("‚ùå Ge√ßerli bir build ID bulunamadƒ±!");
        return false;
    }

    const consoleLogUrl = `http://localhost:8080/job/testBase/${buildId}/consoleText`;
    console.log(`‚è≥ Jenkins √ßƒ±ktƒ±sƒ± kontrol ediliyor: ${consoleLogUrl}`);

    let attempts = 0;
    const maxAttempts = 30;

    while (attempts < maxAttempts) {
        try {
            const response = await axios.get(consoleLogUrl, {
                auth: { username: JENKINS_USER, password: JENKINS_TOKEN }
            });

            if (response.data.includes("Finished: SUCCESS")) {
                console.log("‚úÖ Jenkins job ba≈üarƒ±yla tamamlandƒ±!");
                return true;
            }

            if (response.data.includes("Finished: FAILURE") || response.data.includes("Finished: ABORTED")) {
                console.error("‚ùå Jenkins job ba≈üarƒ±sƒ±z veya iptal edildi!");
                return false;
            }

        } catch (error) {
            console.error("‚ùå Jenkins console log okunurken hata:", error.message);
        }

        console.log(`üîÑ Jenkins bitmemi≈ü, 5 saniye sonra tekrar kontrol edilecek... (${attempts + 1}/30)`);
        await new Promise(resolve => setTimeout(resolve, 5000));
        attempts++;
    }

    console.error("‚è≥ Jenkins 2.5 dakika boyunca bitmedi, API timeout!");
    return false;
}

// ‚úÖ **Son olu≈üturulan WebM dosyasƒ±nƒ± bul**
function getNewestWebmFile(dir) {
    console.log(`üìÇ ${dir} klas√∂r√ºndeki dosyalar kontrol ediliyor...`);

    if (!fs.existsSync(dir)) {
        console.error("‚ùå Video dizini mevcut deƒüil!");
        return null;
    }

    const files = fs.readdirSync(dir);
    console.log(`üìù Bulunan dosyalar:`, files);

    const webmFiles = files.filter(f => f.endsWith('.webm'));
    if (webmFiles.length === 0) {
        console.error("‚ö†Ô∏è WebM dosyasƒ± bulunamadƒ±!");
        return null;
    }

    const sorted = webmFiles
        .map(file => ({ file, time: fs.statSync(path.join(dir, file)).mtime.getTime() }))
        .sort((a, b) => b.time - a.time);

    const newestFile = sorted[0]?.file || null;
    console.log(`‚úÖ En son olu≈üturulan WebM dosyasƒ±: ${newestFile}`);

    return newestFile;
}


// ‚úÖ **WebM ‚Üí MP4 d√∂n√º≈ü√ºm√º**
function convertWebMtoMP4(webmPath) {
    return new Promise((resolve, reject) => {
        const mp4Path = webmPath.replace('.webm', '.mp4');
        console.log(`üé• WebM dosyasƒ± MP4'e √ßevriliyor: ${webmPath} ‚Üí ${mp4Path}`);

        const ffmpegCommand = `ffmpeg -y -i "${webmPath}" -vf "crop=in_w:in_h-20:0:0" -c:v libx264 -preset slow -crf 23 -b:v 2M "${mp4Path}"`;
        console.log(`üîÑ FFmpeg √ßalƒ±≈ütƒ±rƒ±lƒ±yor: ${ffmpegCommand}`);

        const process = exec(ffmpegCommand, { timeout: 15000 });

        process.stdout.on("data", (data) => console.log("üìù FFmpeg stdout:", data));
        process.stderr.on("data", (data) => console.log("‚ö†Ô∏è FFmpeg stderr:", data));

        process.on("exit", (code) => {
            if (code === 0) {
                console.log("‚úÖ MP4 dosyasƒ± ba≈üarƒ±yla olu≈üturuldu:", mp4Path);
                resolve(mp4Path);
            } else {
                console.error("‚ùå FFmpeg hatayla √ßƒ±ktƒ±, kod:", code);
                reject(new Error(`FFmpeg ba≈üarƒ±sƒ±z oldu, √ßƒ±kƒ±≈ü kodu: ${code}`));
            }
        });

        process.on("error", (err) => {
            console.error("‚ùå FFmpeg √ßalƒ±≈ütƒ±rƒ±lamadƒ±:", err);
            reject(err);
        });

        process.on("close", (code) => {
            console.log(`üîö FFmpeg s√ºreci kapandƒ±, √ßƒ±kƒ±≈ü kodu: ${code}`);
        });
    });
}





// ‚úÖ **MP4 ‚Üí Thumbnail olu≈üturma**
function createThumbnail(mp4Path) {
    return new Promise((resolve, reject) => {
        const thumbnailPath = mp4Path.replace('.mp4', '.png');
        console.log(`üì∏ Thumbnail olu≈üturuluyor: ${mp4Path} ‚Üí ${thumbnailPath}`);

        const ffmpegCommand = `ffmpeg -y -i "${mp4Path}" -vf "crop=in_w:in_h-20:0:0" -ss 00:00:2 -vframes 1 "${thumbnailPath}"`;
        console.log(`üîÑ FFmpeg √ßalƒ±≈ütƒ±rƒ±lƒ±yor: ${ffmpegCommand}`);

        const process = exec(ffmpegCommand, { timeout: 15000 });

        process.stdout.on("data", (data) => console.log("üìù FFmpeg stdout:", data));
        process.stderr.on("data", (data) => console.log("‚ö†Ô∏è FFmpeg stderr:", data));

        process.on("exit", (code) => {
            if (code === 0) {
                console.log("‚úÖ Thumbnail ba≈üarƒ±yla olu≈üturuldu:", thumbnailPath);
                resolve(thumbnailPath);
            } else {
                console.error("‚ùå FFmpeg hatayla √ßƒ±ktƒ±, kod:", code);
                reject(new Error(`FFmpeg ba≈üarƒ±sƒ±z oldu, √ßƒ±kƒ±≈ü kodu: ${code}`));
            }
        });

        process.on("error", (err) => {
            console.error("‚ùå FFmpeg √ßalƒ±≈ütƒ±rƒ±lamadƒ±:", err);
            reject(err);
        });

        process.on("close", (code) => {
            console.log(`üîö FFmpeg s√ºreci kapandƒ±, √ßƒ±kƒ±≈ü kodu: ${code}`);
        });
    });
}






// ‚úÖ **Run Test Endpoint**
app.post('/run-test', async (req, res) => {
    try {
        console.log("üîπ Yeni test ba≈ülatƒ±lƒ±yor...");
        const { testName, steps } = req.body;

        if (!testName || !testName.trim()) return res.status(400).json({ error: 'Test Name is required' });
        if (!steps || steps.length === 0) return res.status(400).json({ error: 'No test steps provided' });

        const testFileName = testName.replace(/\s+/g, '_') + '.spec.js';
        const testFilePath = path.join(TESTS_DIR, testFileName);
        let testScript = `
import { test, expect, chromium } from '@playwright/test';
import { customClick, customFill, customWaitForTimeout, customLocator, waitForLoadState, customPlaceholder } from '../utilities/utilities.js';

test('${testName}', async ({  }) => {
 const browser = await chromium.launch({
        headless: true,
        args: ['--window-position=0,0', '--window-size=1920,1080']
    });

    const context = await browser.newContext({ recordVideo: { dir: 'videos/' } });
    const page = await context.newPage();
    try {
        console.log("Test ba≈üladƒ±...");`;

        steps.forEach(({ testButton, selectedStep, value }) => {
            if (testButton === 'Goto URL') testScript += `await page.goto('${selectedStep}');\n`;
            if (testButton === 'Click Button') testScript += `await customClick(customLocator(page, '${selectedStep}'), '${testButton}', page);\n`;
            if (testButton === 'Fill Button') testScript += `await customFill(customLocator(page, '${selectedStep}'), '${value || ''}', '${testButton}', page);\n`;
            if (testButton === 'Wait For Timeout') testScript += `await customWaitForTimeout(${value || 3000});\n`;
            if (testButton === "Wait For Load State") testScript += `await waitForLoadState(page,"${value}");\n`;
            if(testButton === "PlaceHolder Click Button") testScript += `await customClick(customPlaceholder(page, '${value}'), '${testButton}', page);\n`;
            if(testButton === "PlaceHolder Fill Button") testScript += `await customFill(customPlaceholder(page, '${selectedStep}'), '${value}','${testButton}', page);\n`;
        });

        testScript += `await context.close(); } catch (error) { console.error("Hata:", error); throw error; } });`;

        fs.writeFileSync(testFilePath, testScript, 'utf-8');

        console.log(`üöÄ Jenkins Pipeline tetikleniyor. Test dosyasƒ±: ${testFileName}`);

        await axios.post(`${JENKINS_URL}?TOKEN=${JENKINS_TOKEN}&TEST_FILE=${testFileName}`, {}, {
            auth: { username: JENKINS_USER, password: JENKINS_TOKEN },
            headers: { 'Content-Type': 'application/json' }
        });


        await new Promise(resolve => setTimeout(resolve, 5000));
        const buildId = await getLastBuildId();
        if (!buildId) return res.status(500).json({ error: 'Jenkins build ID alƒ±namadƒ±' });

        const success = await waitForJenkinsSuccess(buildId);
        if (!success) return res.status(500).json({ error: 'Jenkins ba≈üarƒ±sƒ±z oldu!' });

        const screenshots = fs.readdirSync(SCREENSHOTS_DIR)
            .filter(file => file.endsWith('.png'))
            .map(file => path.join('/screenshots', file))
            .sort((a, b) => {
                const statA = fs.statSync(path.join(SCREENSHOTS_DIR, a.replace('/screenshots/', '')));
                const statB = fs.statSync(path.join(SCREENSHOTS_DIR, b.replace('/screenshots/', '')));
                return statB.mtime - statA.mtime; // Yeni dosyalar √∂nce gelsin
            });

        console.log("‚úÖ Ekran g√∂r√ºnt√ºleri ba≈üarƒ±yla alƒ±ndƒ±!");






        console.log("üîç Video dosyasƒ± aranƒ±yor...");
        const webmFile = getNewestWebmFile(VIDEOS_DIR);
        if (!webmFile) return res.status(500).json({ error: 'WebM dosyasƒ± bulunamadƒ±!' });

        const webmPath = path.join(VIDEOS_DIR, webmFile);
        console.log(`üé• WebM bulunup i≈üleniyor: ${webmPath}`);

        let mp4Path, thumbnailPath;

        try {
            mp4Path = await convertWebMtoMP4(webmPath);
            console.log(`‚úÖ MP4 dosyasƒ± olu≈üturuldu: ${mp4Path}`);

            thumbnailPath = await createThumbnail(mp4Path);
            console.log(`‚úÖ Thumbnail dosyasƒ± olu≈üturuldu: ${thumbnailPath}`);

        } catch (error) {
            console.error("‚ùå Video veya Thumbnail d√∂n√º≈üt√ºrme ba≈üarƒ±sƒ±z:", error);
            return res.status(500).json({ error: "Video veya Thumbnail d√∂n√º≈üt√ºrme ba≈üarƒ±sƒ±z!" });
        }

        console.log("‚úÖ Test tamamlandƒ±, video ve thumbnail olu≈üturuldu!");
        res.json({
            message: "Test ba≈üarƒ±yla tamamlandƒ±.",
            video: path.basename(mp4Path),
            thumbnail: path.basename(thumbnailPath),
            screenshots
        });

    } catch (err) {
        console.error("‚ùå Genel hata:", err.message);
        if (!res.headersSent) {
            return res.status(500).json({ error: err.message });
        }
    }
});


app.get('/api/screenshots', (req, res) => {
    if (!fs.existsSync(SCREENSHOTS_DIR)) {
        return res.status(404).json({ error: "Screenshots directory not found!" });
    }

    fs.readdir(SCREENSHOTS_DIR, (err, files) => {
        if (err) {
            return res.status(500).json({ error: 'Error reading screenshots directory' });
        }

        // Sadece `.png` dosyalarƒ±nƒ± al ve sƒ±ralƒ± bir liste olarak d√∂nd√ºr
        const screenshots = files
            .filter(file => file.endsWith('.png'))
            .map(file => path.join('/screenshots', file)) // Sunucuya doƒüru yol
            .sort((a, b) => {
                const statA = fs.statSync(path.join(SCREENSHOTS_DIR, a.replace('/screenshots/', '')));
                const statB = fs.statSync(path.join(SCREENSHOTS_DIR, b.replace('/screenshots/', '')));
                return statB.mtime - statA.mtime; // Yeni dosyalar √∂nce gelsin
            });

        res.json(screenshots);
    });
});

// ‚úÖ **Screenshots klas√∂r√ºn√º statik olarak sun**
app.use('/screenshots', express.static(SCREENSHOTS_DIR));

app.listen(PORT, () => {
    console.log('Server running on port ' + PORT);
});
